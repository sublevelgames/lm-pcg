<!DOCTYPE html>
<html>
<head>
    <title>Mindcraft Puzzle Visualizer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .file-selector {
            margin-right: 10px;
            padding: 5px 10px;
            cursor: pointer;
        }
        .puzzle-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 20px;
        }
        .puzzle-container {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .puzzle-info {
            margin-bottom: 10px;
            font-size: 14px;
        }
        canvas {
            border: 1px solid #ddd;
            display: block;
            margin: 0 auto;
        }
        .error {
            color: red;
            padding: 10px;
        }
        .puzzle-info {
            margin-bottom: 10px;
            font-size: 14px;
            line-height: 1.5;
        }
        .puzzle-info small {
            font-size: 12px;
        }
        .collapsible-header {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .collapsible-header:hover {
            opacity: 0.8;
        }

        .collapse-icon {
            display: inline-block;
            transition: transform 0.3s ease;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .collapsible-content.collapsed {
            max-height: 0;
        }
    </style>
</head>
<body>
    <h1>Mindcraft Puzzle Visualizer</h1>
    
    <div class="controls">
        <label>Select puzzle file:</label>
        <select id="fileSelector" class="file-selector">
            <option value="puzzle_no_gimmick_all.json">No Gimmick</option>
            <option value="puzzle_bridge_all.json">Bridge</option>
            <option value="puzzle_glass_all.json">Glass</option>
            <option value="puzzle_switch_all.json">Switch</option>
        </select>
        <span id="puzzleCount"></span>
        
        <label style="margin-left: 20px;">Sort by:</label>
        <select id="sortSelector" class="file-selector">
            <option value="none">None</option>
            <option value="moves">Solution Length</option>
            <option value="switches">Switch Count</option>
        </select>
        
        <label style="margin-left: 20px;">
            <input type="checkbox" id="showCollectables"> Show Collectables
        </label>
        <label style="margin-left: 20px;">
            <input type="checkbox" id="showSolution" checked> Show Solution
        </label>
    </div>

    <div class="solver-section" style="margin-top: 20px; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
        <h2 class="collapsible-header" id="solverHeader">
            <span class="collapse-icon" id="solverCollapseIcon">▼</span>
            Puzzle Solver
        </h2>
        <div class="collapsible-content collapsed" id="solverContent">
            <div style="display: flex; gap: 20px; margin-top: 15px;">
                <div style="flex: 1;">
                    <label>Input puzzle grid:</label><br>
                    <textarea id="puzzleInput" style="width: 100%; height: 300px; font-family: monospace; font-size: 14px;" placeholder="Enter puzzle grid...
    Example:
    __....1_
    _.......
    _.......
    ..._....
    ..._....
    ..___.._
    ..__..__
    ......._
    ......._
    .g.__.._
    ......_."></textarea>
                    <button id="solveButton" style="margin-top: 10px; padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Solve Puzzle</button>
                </div>
                <div style="flex: 1;">
                    <label>Solution:</label>
                    <div id="solverResult" style="min-height: 300px; padding: 10px; background: #f5f5f5; border-radius: 4px; font-family: monospace;"></div>
                    <canvas id="solverCanvas" style="margin-top: 10px; border: 1px solid #ddd; display: none;"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <div id="error" class="error" style="display:none;"></div>
    <div id="puzzles" class="puzzle-grid"></div>

    <script>
        const TILE_SIZE = 30;
        const COLORS = {
            '_': '#333',        // void
            '.': '#e0e0e0',     // floor
            '1': '#4CAF50',     // player
            '2': '#4CAF50',     // player type 2
            '3': '#4CAF50',     // player type 3
            'g': '#FF5722',     // goal
            '*': '#64B5F6',     // glass
            'a': '#FFC107',     // switch a
            'b': '#FFA726',     // switch b
            'c': '#FF7043',     // switch c
            'd': '#AB47BC',     // switch d
            'e': '#7E57C2',     // switch e
            'A': '#FFB300',     // switch wall A
            'B': '#FB8C00',     // switch wall B
            'C': '#F4511E',     // switch wall C
            'D': '#8E24AA',     // switch wall D
            'E': '#5E35B1',     // switch wall E
            'H': '#9C27B0',     // bridge
            'h': '#7B1FA2',     // bridge switch
            'o': '#795548',     // obstacle
            '-': '#F44336',     // laser horizontal
            '+': '#E91E63'      // laser vertical
        };

        let currentPuzzles = [];
        let showCollectables = false;
        let showSolution = true;

        // 퍼즐 솔버 관련 코드
        const nn = [[-1,0],[0,-1],[1,0],[0,1]]; // W N E S

        const pos_obj = {
            '1': [[0,0]],
            '2': [[0,0],[1,0]],
            '3': [[0,-1],[0,0]]
        };

        const move_obj = {
            '1': [
                // W
                [[-1,0],[-2,0], 2],
                // N
                [[0,-1],[0,-2], 3],
                // E
                [[1,0],[2,0], 2],
                // S
                [[0,1],[0,2], 3]
            ],
            '2': [
                // W
                [[-1,0], 1],
                // N
                [[0,-1], [1,-1], 2],
                // E
                [[2,0], 1],
                // S
                [[0,1], [1,1], 2]
            ],
            '3': [
                // W
                [[-1,0], [-1,-1], 3],
                // N
                [[0,-2], 1],
                // E
                [[1,0], [1,-1], 3],
                // S
                [[0,1], 1]
            ]
        };

        const nn_obj = {
            '1': [
                [-2, 0], // W
                [0, -1], // N
                [1, 0],  // E
                [0, 2]   // S
            ],
            '2': [
                [-1, 0], // W
                [0, -1], // N
                [2, 0],  // E
                [0, 1]   // S
            ],
            '3': [
                [-1, 0],  // W
                [0, -2],  // N
                [1, 0],   // E
                [0, 1]    // S
            ]
        };

        function sortPuzzles(puzzles, sortType) {
            const sortedPuzzles = [...puzzles]; // 복사본 생성
            
            // console.log('Sorting by:', sortType); // 디버그용
            
            switch(sortType) {
                case 'moves':
                    sortedPuzzles.sort((a, b) => {
                        // console.log(`Comparing: ${a.move.length} vs ${b.move.length}`); // 디버그용
                        return b.move.length - a.move.length;
                    });
                    break;
                case 'switches':
                    sortedPuzzles.sort((a, b) => {
                        const switchCountA = a.switch ? a.switch.split('|').length : 0;
                        const switchCountB = b.switch ? b.switch.split('|').length : 0;
                        // console.log(`Comparing switches: ${switchCountA} vs ${switchCountB}`); // 디버그용
                        return switchCountB - switchCountA;
                    });
                    break;
                default:
                    // console.log('No sorting applied'); // 디버그용
                    break;
            }
            
            // 정렬 결과 확인
            // console.log('First 5 puzzles after sorting:', sortedPuzzles.slice(0, 5).map(p => ({
            //     moves: p.move.length,
            //     switches: p.switch ? p.switch.split('|').length : 0
            // })));
            
            return sortedPuzzles;
        }

        async function loadPuzzleFile(filename) {
            try {
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`Failed to load ${filename}`);
                }
                const data = await response.json();
                return data;
            } catch (error) {
                showError(`Error loading ${filename}: ${error.message}`);
                return [];
            }
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
        }

        function drawPuzzle(puzzle, index) {
            const container = document.createElement('div');
            container.className = 'puzzle-container';
            
            // drawPuzzle 함수 내 info 부분 수정
            const info = document.createElement('div');
            info.className = 'puzzle-info';
            let gimmickText = puzzle.gimmick ? puzzle.gimmick.join(', ') : 'none';
            let switchCount = puzzle.switch ? puzzle.switch.split('|').length : 0;

            // move 배열을 파싱하여 표시
            let moveText = '';
            if (puzzle.move && puzzle.move.length > 0) {
                moveText = puzzle.move.map((move, idx) => {
                    const parts = move.split('#');
                    const x = parts[0];
                    const y = parts[1];
                    const type = parts[2];
                    return `(${x},${y})`;
                }).join(' → ');
            }

            info.innerHTML = `
                <strong>Puzzle ${index + 1}</strong> | 
                Size: ${puzzle.grid_w}x${puzzle.grid_h} | 
                Gimmicks: ${gimmickText} | 
                Moves: ${puzzle.move.length}${switchCount > 0 ? ` | Switches: ${switchCount}` : ''}<br>
                <small style="color: #666;">Path: ${moveText}</small>
            `;
            
            // Canvas 생성
            const canvas = document.createElement('canvas');
            canvas.width = puzzle.grid_w * TILE_SIZE;
            canvas.height = puzzle.grid_h * TILE_SIZE;
            const ctx = canvas.getContext('2d');
            
            // 그리드 그리기
            for (let i = 0; i < puzzle.grid.length; i++) {
                const x = (i % puzzle.grid_w) * TILE_SIZE;
                const y = Math.floor(i / puzzle.grid_w) * TILE_SIZE;
                const tile = puzzle.grid[i];
                
                // 타일 배경
                ctx.fillStyle = COLORS[tile] || '#666';
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                
                // 타일 테두리
                ctx.strokeStyle = '#999';
                ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
                
                // 특수 타일 표시
                ctx.fillStyle = '#fff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                if (tile === '1' || tile === '2' || tile === '3') {
                    // 플레이어 블록 (1x1x2 표시)
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(x + 5, y + 5, TILE_SIZE - 10, TILE_SIZE - 10);
                    ctx.fillStyle = COLORS[tile];
                    ctx.fillRect(x + 8, y + 8, TILE_SIZE - 16, TILE_SIZE - 16);
                    ctx.fillStyle = '#fff';
                    ctx.fillText(tile, x + TILE_SIZE/2, y + TILE_SIZE/2);
                } else if (tile === 'g') {
                    ctx.fillText('G', x + TILE_SIZE/2, y + TILE_SIZE/2);
                } else if (tile === '*') {
                    ctx.fillText('※', x + TILE_SIZE/2, y + TILE_SIZE/2);
                } else if (tile === 'o') {
                    ctx.fillText('O', x + TILE_SIZE/2, y + TILE_SIZE/2);
                } else if (tile === '-' || tile === '+') {
                    ctx.fillText(tile, x + TILE_SIZE/2, y + TILE_SIZE/2);
                } else if (tile !== '_' && tile !== '.') {
                    ctx.fillStyle = '#000';
                    ctx.fillText(tile, x + TILE_SIZE/2, y + TILE_SIZE/2);
                }
            }
            
            // Collectables 그리기
            if (showCollectables && puzzle.collectables) { // 조건 추가
                const collectables = puzzle.collectables.split('#').map(c => parseInt(c));
                ctx.fillStyle = COLORS.collectable || '#FFD700';
                collectables.forEach(pos => {
                    if (!isNaN(pos)) {
                        const x = (pos % puzzle.grid_w) * TILE_SIZE;
                        const y = Math.floor(pos / puzzle.grid_w) * TILE_SIZE;
                        ctx.beginPath();
                        ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }

            // 이동 경로 시각화
            if (showSolution && puzzle.move && puzzle.move.length > 0) {
                // 플레이어 블록 형태 정의 (pos_obj와 동일)
                const playerShapes = {
                    '1': [[0, 0]],           // 1x1 (서있는 상태)
                    '2': [[0, 0], [1, 0]],   // 2x1 (가로로 누운 상태)
                    '3': [[0, -1], [0, 0]]   // 1x2 (세로로 누운 상태)
                };
                
                // 각 이동 위치 그리기
                puzzle.move.forEach((move, idx) => {
                    const parts = move.split('#');
                    const px = parseInt(parts[0]);
                    const py = parseInt(parts[1]);
                    const ptype = parts[2];
                    
                    // 플레이어 타입에 따른 모양 가져오기
                    const shape = playerShapes[ptype] || playerShapes['1'];
                    
                    // 반투명하게 그리기 (이동 순서에 따라 투명도 조절)
                    const opacity = 0.3 + (idx / puzzle.move.length) * 0.4;
                    
                    // 블록 타입에 따라 하나의 연결된 모양으로 그리기
                    ctx.fillStyle = `rgba(76, 175, 80, ${opacity})`;
                    ctx.strokeStyle = `rgba(33, 150, 33, ${opacity})`;
                    ctx.lineWidth = 2;
                    
                    if (ptype === '1') {
                        // 1x1 블록 (서있는 상태)
                        const blockX = px * TILE_SIZE;
                        const blockY = py * TILE_SIZE;
                        ctx.fillRect(blockX + 4, blockY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                        ctx.strokeRect(blockX + 4, blockY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                    } else if (ptype === '2') {
                        // 2x1 블록 (가로로 누운 상태) - 하나의 긴 사각형
                        const blockX = px * TILE_SIZE;
                        const blockY = py * TILE_SIZE;
                        ctx.fillRect(blockX + 4, blockY + 4, TILE_SIZE * 2 - 8, TILE_SIZE - 8);
                        ctx.strokeRect(blockX + 4, blockY + 4, TILE_SIZE * 2 - 8, TILE_SIZE - 8);
                    } else if (ptype === '3') {
                        // 1x2 블록 (세로로 누운 상태) - 하나의 긴 사각형
                        const blockX = px * TILE_SIZE;
                        const blockY = (py - 1) * TILE_SIZE; // 위쪽 타일부터 시작
                        ctx.fillRect(blockX + 4, blockY + 4, TILE_SIZE - 8, TILE_SIZE * 2 - 8);
                        ctx.strokeRect(blockX + 4, blockY + 4, TILE_SIZE - 8, TILE_SIZE * 2 - 8);
                    }
                    
                    // 시작점과 끝점 표시
                    if (idx === 0) {
                        // 시작점 표시 (S)
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('S', px * TILE_SIZE + TILE_SIZE/2, py * TILE_SIZE + TILE_SIZE/2);
                    } else if (idx === puzzle.move.length - 1) {
                        // 끝점 표시 (E)
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('E', px * TILE_SIZE + TILE_SIZE/2, py * TILE_SIZE + TILE_SIZE/2);
                    }
                });
                
                // 이동 경로 선 그리기
                ctx.strokeStyle = 'rgba(76, 175, 80, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                
                puzzle.move.forEach((move, idx) => {
                    const parts = move.split('#');
                    const px = parseInt(parts[0]);
                    const py = parseInt(parts[1]);
                    
                    if (idx === 0) {
                        ctx.moveTo(px * TILE_SIZE + TILE_SIZE/2, py * TILE_SIZE + TILE_SIZE/2);
                    } else {
                        ctx.lineTo(px * TILE_SIZE + TILE_SIZE/2, py * TILE_SIZE + TILE_SIZE/2);
                    }
                });
                
                ctx.stroke();
                ctx.setLineDash([]); // 점선 해제
            }
            
            container.appendChild(info);
            container.appendChild(canvas);
            return container;
        }

        async function displayPuzzles(filename) {
            hideError();
            const puzzlesDiv = document.getElementById('puzzles');
            puzzlesDiv.innerHTML = '<p>Loading...</p>';
            
            // 파일명이 바뀌었을 때만 새로 로드
            if (!filename && currentPuzzles.length > 0) {
                // 파일명이 없으면 현재 퍼즐로 다시 표시 (정렬만 변경)
                renderPuzzles(currentPuzzles);
            } else {
                // 새로운 파일 로드
                currentPuzzles = await loadPuzzleFile(filename);
                renderPuzzles(currentPuzzles);
            }
        }

        function renderPuzzles(puzzles) {
            const puzzlesDiv = document.getElementById('puzzles');
            
            if (puzzles.length === 0) {
                puzzlesDiv.innerHTML = '<p>No puzzles loaded.</p>';
                return;
            }
            
            // 정렬 적용
            const sortType = document.getElementById('sortSelector').value;
            const sortedPuzzles = sortPuzzles(puzzles, sortType);
            
            puzzlesDiv.innerHTML = '';
            document.getElementById('puzzleCount').textContent = `(${sortedPuzzles.length} puzzles)`;
            
            // 최대 100개만 표시 (성능 고려)
            const displayCount = Math.min(sortedPuzzles.length, 100);
            for (let i = 0; i < displayCount; i++) {
                const puzzleElement = drawPuzzle(sortedPuzzles[i], i);
                puzzlesDiv.appendChild(puzzleElement);
            }
            
            if (displayCount < sortedPuzzles.length) {
                const notice = document.createElement('p');
                notice.textContent = `Showing first ${displayCount} of ${sortedPuzzles.length} puzzles`;
                notice.style.textAlign = 'center';
                notice.style.padding = '20px';
                puzzlesDiv.appendChild(notice);
            }
        }

        function solvePuzzle(gridStr) {
            // 그리드 파싱
            const lines = gridStr.trim().split('\n');
            const grid_h = lines.length;
            const grid_w = lines[0].length;
            const grid = lines.join('').split('');
            
            // 시작점과 목표점 찾기
            let start_pos = grid.indexOf('1');
            let goal_pos = grid.indexOf('g');
            
            if (start_pos === -1) {
                return { solved: false, error: "No starting position (1) found" };
            }
            if (goal_pos === -1) {
                return { solved: false, error: "No goal position (g) found" };
            }
            
            // BFS로 해 찾기
            let x = start_pos % grid_w;
            let y = Math.floor(start_pos / grid_w);
            
            let queue = [[`${x}#${y}#1`, []]]; // [state, path]
            let visited = {};
            visited[queue[0][0]] = true;
            
            while (queue.length > 0) {
                let [currentState, path] = queue.shift();
                let [cx, cy, ctype] = currentState.split('#').map((v, i) => i < 2 ? parseInt(v) : v);
                
                // 4방향 탐색
                for (let dir = 0; dir < 4; dir++) {
                    let nx = cx + nn_obj[ctype][dir][0];
                    let ny = cy + nn_obj[ctype][dir][1];
                    let nidx = ny * grid_w + nx;
                    
                    // 경계 체크
                    if (nx < 0 || nx >= grid_w || ny < 0 || ny >= grid_h) continue;
                    
                    // 이동 가능 여부 체크
                    const move_arr = move_obj[ctype][dir];
                    const moved_type = move_arr[move_arr.length - 1];
                    let canMove = true;
                    
                    // 경로상의 모든 타일 체크
                    for (let k = 0; k < move_arr.length - 1; k++) {
                        let check_x = cx + move_arr[k][0];
                        let check_y = cy + move_arr[k][1];
                        let check_idx = check_y * grid_w + check_x;
                        
                        if (check_x < 0 || check_x >= grid_w || 
                            check_y < 0 || check_y >= grid_h || 
                            grid[check_idx] === '_') {
                            canMove = false;
                            break;
                        }
                    }
                    
                    if (!canMove) continue;
                    
                    // 목표 도달 체크
                    if (nx === goal_pos % grid_w && ny === Math.floor(goal_pos / grid_w) && moved_type === 1) {
                        return {
                            solved: true,
                            path: [...path, currentState, `${nx}#${ny}#${moved_type}`],
                            grid: grid,
                            grid_w: grid_w,
                            grid_h: grid_h
                        };
                    }
                    
                    // 새로운 상태 추가
                    let newState = `${nx}#${ny}#${moved_type}`;
                    if (!visited[newState]) {
                        visited[newState] = true;
                        queue.push([newState, [...path, currentState]]);
                    }
                }
            }
            
            return { solved: false, error: "No solution found" };
        }

        // 파일 선택 이벤트
        document.getElementById('fileSelector').addEventListener('change', (e) => {
            displayPuzzles(e.target.value);
        });

        // 정렬 선택 이벤트
        document.getElementById('sortSelector').addEventListener('change', (e) => {
            if (currentPuzzles.length > 0) {
                renderPuzzles(currentPuzzles);
            }
        });

        // 체크박스 이벤트
        document.getElementById('showCollectables').addEventListener('change', (e) => {
            showCollectables = e.target.checked;
            if (currentPuzzles.length > 0) {
                renderPuzzles(currentPuzzles);
            }
        });

        // 해답 체크박스 이벤트
        document.getElementById('showSolution').addEventListener('change', (e) => {
            showSolution = e.target.checked;
            if (currentPuzzles.length > 0) {
                renderPuzzles(currentPuzzles);
            }
        });

        // Solve 버튼 이벤트
        document.getElementById('solveButton').addEventListener('click', () => {
            const input = document.getElementById('puzzleInput').value;
            const resultDiv = document.getElementById('solverResult');
            const canvas = document.getElementById('solverCanvas');
            
            if (!input.trim()) {
                resultDiv.textContent = 'Please enter a puzzle grid';
                canvas.style.display = 'none';
                return;
            }
            
            // 입력된 그리드 파싱 (결과와 무관하게 시각화를 위해)
            const lines = input.trim().split('\n');
            const grid_h = lines.length;
            const grid_w = lines[0].length;
            const grid = lines.join('').split('');
            
            const result = solvePuzzle(input);
            
            // 캔버스 설정 및 그리드 그리기 (해답 유무와 관계없이)
            canvas.style.display = 'block';
            canvas.width = grid_w * TILE_SIZE;
            canvas.height = grid_h * TILE_SIZE;
            const ctx = canvas.getContext('2d');
            
            // 그리드 그리기
            for (let i = 0; i < grid.length; i++) {
                const x = (i % grid_w) * TILE_SIZE;
                const y = Math.floor(i / grid_w) * TILE_SIZE;
                const tile = grid[i];
                
                ctx.fillStyle = COLORS[tile] || '#666';
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                
                ctx.strokeStyle = '#999';
                ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
                
                // 특수 타일 표시
                ctx.fillStyle = '#fff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                if (tile === '1') {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(x + 5, y + 5, TILE_SIZE - 10, TILE_SIZE - 10);
                    ctx.fillStyle = COLORS[tile];
                    ctx.fillRect(x + 8, y + 8, TILE_SIZE - 16, TILE_SIZE - 16);
                    ctx.fillStyle = '#fff';
                    ctx.fillText(tile, x + TILE_SIZE/2, y + TILE_SIZE/2);
                } else if (tile === 'g') {
                    ctx.fillText('G', x + TILE_SIZE/2, y + TILE_SIZE/2);
                }
            }
            
            if (result.solved) {
                // 해답 표시
                let pathText = result.path.map((move, idx) => {
                    const parts = move.split('#');
                    return `Step ${idx}: (${parts[0]},${parts[1]}) Type:${parts[2]}`;
                }).join('\n');
                
                resultDiv.innerHTML = `<strong style="color: green;">✓ Solution found!</strong>\n\nMoves: ${result.path.length - 1}\n\n${pathText}`;
                
                // 해답 경로 그리기 (showSolution이 true일 때만)
                if (showSolution) {
                    const playerShapes = {
                        '1': [[0, 0]],
                        '2': [[0, 0], [1, 0]],
                        '3': [[0, -1], [0, 0]]
                    };
                    
                    result.path.forEach((move, idx) => {
                        const parts = move.split('#');
                        const px = parseInt(parts[0]);
                        const py = parseInt(parts[1]);
                        const ptype = parts[2];
                        
                        const opacity = 0.3 + (idx / result.path.length) * 0.4;
                        ctx.fillStyle = `rgba(76, 175, 80, ${opacity})`;
                        ctx.strokeStyle = `rgba(33, 150, 33, ${opacity})`;
                        ctx.lineWidth = 2;
                        
                        if (ptype === '1') {
                            const blockX = px * TILE_SIZE;
                            const blockY = py * TILE_SIZE;
                            ctx.fillRect(blockX + 4, blockY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                            ctx.strokeRect(blockX + 4, blockY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                        } else if (ptype === '2') {
                            const blockX = px * TILE_SIZE;
                            const blockY = py * TILE_SIZE;
                            ctx.fillRect(blockX + 4, blockY + 4, TILE_SIZE * 2 - 8, TILE_SIZE - 8);
                            ctx.strokeRect(blockX + 4, blockY + 4, TILE_SIZE * 2 - 8, TILE_SIZE - 8);
                        } else if (ptype === '3') {
                            const blockX = px * TILE_SIZE;
                            const blockY = (py - 1) * TILE_SIZE;
                            ctx.fillRect(blockX + 4, blockY + 4, TILE_SIZE - 8, TILE_SIZE * 2 - 8);
                            ctx.strokeRect(blockX + 4, blockY + 4, TILE_SIZE - 8, TILE_SIZE * 2 - 8);
                        }
                    });
                }
                
            } else {
                resultDiv.innerHTML = `<strong style="color: red;">✗ ${result.error}</strong>`;
                // 캔버스는 이미 위에서 그려졌으므로 별도 처리 불필요
            }
        });

        // Puzzle Solver 토글 기능
        document.getElementById('solverHeader').addEventListener('click', () => {
            const content = document.getElementById('solverContent');
            const icon = document.getElementById('solverCollapseIcon');
            
            content.classList.toggle('collapsed');
            icon.classList.toggle('collapsed');
        });

        // 초기 로드
        window.addEventListener('load', () => {
            displayPuzzles('puzzle_no_gimmick_all.json');
        });
    </script>
</body>
</html>